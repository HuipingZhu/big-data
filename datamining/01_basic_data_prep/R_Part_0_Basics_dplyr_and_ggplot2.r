###############################################################################
# Copyright (C) 2017 J. Patrick Hall, jphall@gwu.edu
#
# Permission is hereby granted, free of charge, to any person obtaining a
# copy of this software and associated documentation files (the "Software"),
# to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom the
# Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
# OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.

### standard output ###########################################################
# two primary R core functions are used to print information to the console
#   print() and cat()
# print is a generic function that responds differently to different classes 
#   of R objects
# note that '.' is just a character, it does not denote object membership
#   as in Java and Python
# cat() simply attempts to print string literals
# an object with no functions or operators is also printed to the console

x <- 'Hello World!'
print(x)
cat(x)
x

class(x) <- 'some.class'
print(x)
cat(x) 
x

### import packages ###########################################################

# R contains thousands of packages for many different purposes
# Packages are:
#   - nearly always free and open source
#   - installed using the install.packages() function or a GUI command
#   - of varying quality and licensing
#   - loaded using the library() function, after being installed

library(dplyr)    # popular package for data wrangling with consistent syntax
library(ggplot2)  # popular package for plotting with consistent syntax

# surpress warnings about versions and object masking
# using suppressPackageStartupMessages()
# suppressPackageStartupMessages(library(dplyr))
# suppressPackageStartupMessages(library(ggplot2))

### working directory #########################################################

# enter the directory location of this file within single quotes
# '<-' is the preferred assignment operator in R
# '/' is the safest directory separator character to use

git_dir <- '/path/to/GWU_data_mining/01_basic_data_prep/src/raw/r'

# set the working directory
# the working directory is where files are written to and read from by default
# setwd() sets the working directory
# getwd() prints the current working directory
setwd(git_dir)
getwd()

### generate a sample data set ################################################

# set the number of rows and columns for the sample data set
n_rows <- 1000
n_vars <- 5

# create a key variable
# a key variable has a unique value for each row of a data set
# seq() generates values from a number (default = 1), to another number, by
#   a certain value (default = 1)
# many types of data structures in R have key variables (a.k.a. row names) by
#   default
key <- seq(n_rows)

# show the first five elements
# most data structures in R can be 'sliced', i.e. using numeric indices
#   to select a subset of items 
key[1:5] 

# create lists of strings that will become column names
# paste() concatentates strings with a separator character in between them
num_vars <- paste('numeric', seq_len(n_vars), sep = '')
num_vars

char_vars <- paste('char', seq_len(n_vars), sep = '')
char_vars

# initialize a data.frame with the key variable
scratch_df <- data.frame(INDEX = key)

# add n_var numeric columns, each with n_row rows, to the data.frame
# each column contains random uniform numeric values generated by runif()
# replicate() replicates n_row length lists of numeric values n_vars times
scratch_df[, num_vars] <- replicate(n_vars, runif(n_rows))

# head() displays the top of a data structure
head(scratch_df) 

# add n_var character columns, each with n_row rows, to the data.frame
# create a list of strings from which to generate random text variables
# sapply() applies a function to a sequence of values
# LETTERS is a character vector containing uppercase letters
# an anonymous function is defined that replicates a value 8 times with no
#   seperator character
# replicate() replicates n_var lists of n_row elements from text_draw sampled
#   randomly from test_draw using the sample() function
text_draw <- sapply(LETTERS[1:7],
                    FUN = function(x) paste(rep(x, 8), collapse = ""))
text_draw

scratch_df[, char_vars] <- replicate(n_vars,
                                     sample(text_draw, n_rows, replace = TRUE))
head(scratch_df)

# convert from standard data.frame to dlpyr table
# dplyr is a popular, intuitive, and effcient package for manipulating data sets
# R has many data types: http://www.statmethods.net/input/datatypes.html
scratch_tbl <- tbl_df(scratch_df)

# use the dplyr::glimpse function to see a summary of the generated data set
glimpse(scratch_tbl)

### plotting variables in the table ###########################################
# ggplot allows you to overlay graphics using the '+' operator
# plot univariate densities of numeric1 and char1 using the geom_bar()
#   components
# gtitle adds title
# coord_flip rotates the bar chart

ggplot(scratch_tbl, aes(numeric1)) +
  geom_bar(stat = "bin", fill = "blue", bins = 100) +
  ggtitle('Histogram of Numeric1')

ggplot(scratch_tbl, aes(char1)) +
  geom_bar(aes(fill=char1)) +
  ggtitle('Histogram of Char1') +
  coord_flip()

### subsetting the table ######################################################

# subset variables using dplyr::select
# subset a range of variables with similar names and numeric suffixes
# subset all the variables whose names begin with 'char'
# subset variables by their names
num_vars <- select(scratch_tbl, num_range('numeric', 1:n_vars))
head(num_vars)

char_vars <- select(scratch_tbl, starts_with('char'))
head(char_vars)

mixed_vars <- select(scratch_tbl, one_of('numeric1', 'char1'))
head(mixed_vars)

# subset rows using multiple dplyr functions
# subset rows using their numeric indices
# subset top rows based on the value of a certain variable
# subset rows where a certain variable has a certain value
some_rows <- slice(scratch_tbl, 1:10)
some_rows

sorted_top_rows <- top_n(scratch_tbl, 10, numeric1)
sorted_top_rows 

AAAAAAAA_rows <- filter(scratch_tbl, char1 == 'AAAAAAAA')
head(AAAAAAAA_rows)

### updating the table ########################################################
# dplyr, as a best practice, does not support in-place overwrites of data 

# dplyr::transform enables the creation of new variables from existing 
#   variables
scratch_tbl2 <- transform(scratch_tbl, 
                          new_numeric = round(numeric1, 1))
head(scratch_tbl2)

# dplyr::mutate enables the creation of new variables from existing 
#   variables and computed variables
scratch_tbl2 <- mutate(scratch_tbl, 
                       new_numeric = round(numeric1, 1), 
                       new_numeric2 = new_numeric * 10)
head(scratch_tbl2)

# dplyr::transmute enables the creation of new variables from existing 
#   variables and computed variables, but keeps only newly created variables
scratch_tbl2 <- transmute(scratch_tbl, 
                          new_numeric = round(numeric1, 1), 
                          new_numeric2 = new_numeric * 10)
head(scratch_tbl2)

### sorting the table #########################################################
# sort tables using dplyr::arrange
# sort by one variable
# sort by two variables

sorted <- arrange(char_vars, char1)
head(sorted)

sorted2 <- arrange(char_vars, char1, char2)
head(sorted2)

### adding data to the table ##################################################
# add data to a table using dplyr:: bind and dplyr::join
# bind smashes tables together
# join combines tables based on matching values of a shared variable

bindr <- bind_rows(sorted, sorted2)
nrow(bindr)

bindc <- bind_cols(sorted, sorted2)
ncol(bindc)

# create two tables to join on a key variable 
sorted_left <- arrange(select(scratch_tbl, one_of('INDEX', 'char1')), char1)
right <- select(scratch_tbl, one_of('INDEX', 'numeric1'))

# Perform join 
# joined table contains `char1` from the left table 
#   and `numeric1` from the right table 
#  matched by the value of `INDEX`
joined <- left_join(sorted_left, right, by = 'INDEX')
head(joined)

### comparing tables ##########################################################
# comparing tables using dplyr::all.equal
# dplyr::all.equal will test tables for equality despite the order of rows
#   and/or columns
# very useful for keeping track of changes to important tables

# Create a table for comparision 
test <- select(scratch_tbl, one_of('INDEX', 'numeric1', 'char1'))

# Compare
print(all.equal(joined, test, ignore_row_order = FALSE))
print(all.equal(joined, test, ignore_col_order = FALSE))
print(all.equal(joined, test))

### summarizing tables ########################################################
# combine rows of tables into summary values with dplyr::summarise and
#   dplyr::summarise_each
# summarize one variable using summarise, avg is the name of the created var
# summarize many variables using summarise_each, funs() defines the summary
#   function

ave <- summarise(num_vars, avg = mean(numeric1))
ave

all_aves <-summarise_each(num_vars, funs(mean))
all_aves

### by group processing #######################################################
# By groups allow you to divide and process a data set based on the values of 
#   one or more variables
# dplyr::group_by groups a data set together based on the values of a certain
#   variable
# operations can then be applied to groups
grouped <- group_by(joined, char1)
grouped <- summarise(grouped, avg = mean(numeric1))
grouped

### Transposing a table #######################################################
# Transposing a matrix simply switches row and columns values
# Transposing a data.frame or dplyr table is more complex because of metadata
#   associated with variable names and row indices

transposed = t(scratch_tbl)
glimpse(transposed)

# Often, instead of simply transposing, a data set will need to be reformatted 
# in a melt/stack-column split-cast action described in Hadley Wickham's 
# 'Tidy Data' https://www.jstatsoft.org/article/view/v059i10
# see also dplyr::gather and dplyr::spread()

### exporting and importing the table #########################################
# the R core function write.table enables writing text files
# the similar R core function read.table enables reading text files

# export
# use the sep option to specifiy the columns delimiter character
# row.names = FALSE indicates not to save the row number to the text file
filename <- paste(git_dir, 'scratch.csv', sep = '/')
write.table(scratch_tbl, file = filename, quote = FALSE, sep = ',',
            row.names = FALSE)

# import
import <- read.table(filename, header = TRUE, sep = ',')